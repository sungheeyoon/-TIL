# 플러터는 왜 선언적 (Declarative) UI 를 채택했을까?

- 작성일: 2024-01-21
- 참조: [Introduction to declarative UI](https://docs.flutter.dev/get-started/flutter-for/declarative)

## 명령적(Imperative) UI vs 선언적(Declarative) UI

**명령적 코드:** 개발자는 어떻게(How)를 명시적으로 작성하며, 프로그램이 어떻게 동작하는지를 세부적으로 제어한다.

```python
# 명령적인 방식: 리스트에서 각 항목을 제곱하여 새로운 리스트 생성
original_list = [1, 2, 3, 4, 5]
squared_list = []

for item in original_list:
    squared_list.append(item ** 2)

print(squared_list)
```

**선언적 코드**: 개발자는 무엇(What)을 선언적으로 표현하며, 원하는 결과를 설명하면서 프레임워크나 런타임에게 동작을 위임한다.

```python
# 선언적인 방식: 리스트 컴프리헨션을 사용하여 간단히 표현
original_list = [1, 2, 3, 4, 5]
squared_list = [item ** 2 for item in original_list]

print(squared_list)
```

**Flutter의 선언적 UI:**
Flutter는 개발자가 UI 상태에 대한 명령형 로직을 작성하는 대신, 현재의 UI 상태를 묘사하고 상태 전환을 프레임워크에 위임하여 개발자 부담을 줄이는 방식으로 작동한다.

## 선언적 UI의 장단점

### 장점

1. **가독성과 간결성:** 코드가 간결하고 읽기 쉽기 때문에 가독성이 높다.
2. **의도 표현:** 개발자는 원하는 결과에 집중하고 코드에서의 구체적인 구현 세부 사항에서 벗어날 수 있다.  
   _(예: 버튼을 묘사하고 클릭 이벤트에 대한 로직은 프레임워크에 위임)_
3. **프레임워크 활용:** 선언적인 스타일은 프레임워크가 상태 및 전이를 효과적으로 처리할 수 있도록 돕는다.

### 단점

1. **일부 제한된 유연성:** 특정 요구 사항에 대해 덜 유연하게 대응할 수 있고, 특별한 상황에서는 명령적인 스타일이 필요할 수 있다.
2. **성능 문제:** 일부 경우에는 선언적인 코드가 명령적인 코드에 비해 성능 면에서 약할 수 있다.

## 명령적 UI의 장단점

### 장점

1. **직관적 제어:** 명령적인 스타일은 개발자가 각 UI 세부 요소를 직접 제어할 수 있어 특정 동작을 세밀하게 조정할 수 있다.
2. **유연성:** 특정 요구 사항에 대해 명령적인 코드는 더 큰 유연성을 제공할 수 있어 일부 복잡한 상황에 대응하기 용이하다.
3. **개발자의 직관을 반영:** 개발자가 코드로 직접 제어하기 때문에 개발자의 직관이 직접 반영되어 UI를 세밀하게 조정할 수 있다.

### 단점

1. **복잡성 증가:** 세부 요소를 직접 제어하는 것은 가독성을 저해하고 코드의 복잡성을 증가시킬 수 있다.
2. **의도 파악 어려움:** 코드의 명령적인 성격으로 인해 개발자의 의도가 명확하지 않을 때가 있어 다른 개발자가 이해하기 어려울 수 있다.
3. **디버깅 어려움:** 세부적인 제어가 많아질수록 버그를 찾고 수정하기 어려워질 수 있다.

## 플러터의 선언적 (Declarative) UI 채택 이유

**UI 전환의 간소화:**
플러터는 선언적 UI를 택한 주요 이유 중 하나는 UI 전환을 간소화하기 위함이다. 선언적 UI 스타일을 사용하면 현재 UI 상태를 명확하게 표현하고, 프레임워크가 상태 전환을 자동으로 처리함으로써 개발자의 부담을 줄일 수 있다.

**불변성과 일관성:**
불변성을 갖는 위젯 구조는 UI를 변경할 때마다 새로운 위젯을 생성하여 상태를 업데이트한다. 이는 코드의 일관성과 예측 가능성을 증가시키며, 개발자가 의도한 대로 UI를 관리할 수 있도록 한다.

**반응적 업데이트 지원:**
setState() 메서드를 통한 반응적 업데이트는 UI 상태의 변경에 민감하게 반응하고, 변경된 부분만 다시 렌더링하여 효율적인 UI 업데이트를 가능케 한다.

**역할의 분리와 RenderObjects 활용:**
플러터는 역할의 분리를 통해 UI 개체의 로우 레벨 렌더링과 레이아웃을 RenderObjects로 관리한다. 가벼운 위젯은 RenderObjects를 조작하도록 지시하며, 프레임워크는 렌더링과 레이아웃 업데이트를 효율적으로 처리한다.
